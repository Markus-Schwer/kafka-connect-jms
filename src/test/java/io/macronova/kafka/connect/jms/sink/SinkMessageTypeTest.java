/*
 * Copyright 2018 Macronova.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.macronova.kafka.connect.jms.sink;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Map;
import java.util.Objects;

import org.junit.Assert;
import org.junit.Test;

import org.apache.activemq.command.ActiveMQBytesMessage;
import org.apache.activemq.command.ActiveMQMapMessage;
import org.apache.activemq.command.ActiveMQObjectMessage;
import org.apache.activemq.command.ActiveMQQueue;
import org.apache.activemq.command.Message;
import org.apache.kafka.common.record.TimestampType;
import org.apache.kafka.connect.data.Schema;
import org.apache.kafka.connect.data.SchemaBuilder;
import org.apache.kafka.connect.data.Struct;
import org.apache.kafka.connect.sink.SinkRecord;

/**
 * Verify structure of different JMS message types generated by sink connector.
 */
public class SinkMessageTypeTest extends BaseSinkTest {
	@Override
	protected boolean isQueueTest() {
		return true;
	}

	@Test
	public void testSimpleMapMessage() throws Exception {
		final Map<String, String> configuration = configurationJndi();
		configuration.put( "jms.message.converter.output.format", "map" );
		final String payload = "Hello, World!";
		final Message message = captureJmsMessage( configuration, payload, Schema.STRING_SCHEMA );
		Assert.assertTrue( message instanceof ActiveMQMapMessage );
		final ActiveMQMapMessage mapMessage = (ActiveMQMapMessage) message;
		Assert.assertEquals( payload, mapMessage.getString( "payload" ) );
	}

	@Test
	public void testStructuredMapMessage() throws Exception {
		final Map<String, String> configuration = configurationJndi();
		configuration.put( "jms.message.converter.output.format", "map" );
		final Struct payload = createStruct(
				new byte[] { 1, 2, 3 }, true, 0.1F, -1.3D, (byte) 1, (short) 13, 123, -123L, "Hello, Kafka!"
		);
		final Message message = captureJmsMessage( configuration, payload, SCHEMA );
		Assert.assertTrue( message instanceof ActiveMQMapMessage );
		final ActiveMQMapMessage mapMessage = (ActiveMQMapMessage) message;
		Assert.assertArrayEquals( new byte[] { 1, 2, 3 }, mapMessage.getBytes( "bytesField" ) );
		Assert.assertEquals( true, mapMessage.getBoolean( "booleanField" ) );
		Assert.assertEquals( 0.1F, mapMessage.getFloat( "float32Field" ), 0.01D );
		Assert.assertEquals( -1.3D, mapMessage.getDouble( "float64Field" ), 0.01D );
		Assert.assertEquals( (byte) 1, mapMessage.getByte( "int8Field" ) );
		Assert.assertEquals( (short) 13, mapMessage.getShort( "int16Field" ) );
		Assert.assertEquals( 123, mapMessage.getInt( "int32Field" ) );
		Assert.assertEquals( -123L, mapMessage.getLong( "int64Field" ) );
		Assert.assertEquals( "Hello, Kafka!", mapMessage.getString( "stringField" ) );
	}

	@Test
	public void testObjectMessage() throws Exception {
		final Map<String, String> configuration = configurationJndi();
		configuration.put( "jms.message.converter.output.format", "object" );
		final Serializable payload = new MySerializableClass( "Hello, Kafka!" );
		final Message message = captureJmsMessage( configuration, payload, Schema.BYTES_SCHEMA );
		Assert.assertTrue( message instanceof ActiveMQObjectMessage );
		final ActiveMQObjectMessage objectMessage = (ActiveMQObjectMessage) message;
		Assert.assertEquals( payload, objectMessage.getObject() );
	}

	@Test
	public void testBytesMessage() throws Exception {
		final Map<String, String> configuration = configurationJndi();
		configuration.put( "jms.message.converter.output.format", "bytes" );
		final byte[] payload = "Hello, Kafka!".getBytes();
		final Message message = captureJmsMessage( configuration, payload, Schema.BYTES_SCHEMA );
		Assert.assertTrue( message instanceof ActiveMQBytesMessage );
		final ActiveMQBytesMessage bytesMessage = (ActiveMQBytesMessage) message;
		bytesMessage.reset();
		final byte[] output = new byte[payload.length];
		bytesMessage.readBytes( output );
		Assert.assertArrayEquals( payload, output );
	}

	private Message captureJmsMessage(Map<String, String> configuration, Object msg, Schema schema) throws Exception {
		SinkRecord record = new SinkRecord( kafkaTopic(), 0, null, null, schema, msg, 0, System.currentTimeMillis(), TimestampType.CREATE_TIME );
		runSink( configuration, Arrays.asList( record ), 1 );
		final Message[] messages = broker.getDestination( new ActiveMQQueue( jmsQueue() ) ).browse();
		Assert.assertEquals( 1, messages.length );
		return messages[0];
	}

	private static final Schema SCHEMA = SchemaBuilder.struct().name( "MultiTypeSchema" ).version( 1 )
			.field( "bytesField", Schema.BYTES_SCHEMA )
			.field( "booleanField", Schema.BOOLEAN_SCHEMA )
			.field( "float32Field", Schema.FLOAT32_SCHEMA )
			.field( "float64Field", Schema.FLOAT64_SCHEMA )
			.field( "int8Field", Schema.INT8_SCHEMA )
			.field( "int16Field", Schema.INT16_SCHEMA )
			.field( "int32Field", Schema.INT32_SCHEMA )
			.field( "int64Field", Schema.INT64_SCHEMA )
			.field( "stringField", Schema.STRING_SCHEMA )
			.build();

	private Struct createStruct(byte[] aBytes, Boolean aBoolean, Float aFloat, Double aDouble, Byte aByte, Short aShort,
								Integer aInt, Long aLong, String aString) {
		return new Struct( SCHEMA )
				.put( "bytesField", aBytes )
				.put( "booleanField", aBoolean )
				.put( "float32Field", aFloat )
				.put( "float64Field", aDouble )
				.put( "int8Field", aByte )
				.put( "int16Field", aShort )
				.put( "int32Field", aInt )
				.put( "int64Field", aLong )
				.put( "stringField", aString );
	}

	public static class MySerializableClass implements Serializable {
		public String text;

		public MySerializableClass(String text) {
			this.text = text;
		}

		@Override
		public boolean equals(Object o) {
			if ( this == o ) return true;
			if ( ! ( o instanceof MySerializableClass ) ) return false;
			final MySerializableClass that = (MySerializableClass) o;
			return Objects.equals( text, that.text );
		}

		@Override
		public int hashCode() {
			return Objects.hash( text );
		}
	}
}
